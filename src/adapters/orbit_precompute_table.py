#!/usr/bin/env python3
"""
Orbit Precompute Table - Fast Query Interface for Precomputed States

用途: 從預計算的 HDF5 表中快速查詢衛星狀態
性能: O(1) 或 O(log n) 查詢，替代實時計算的 O(n) 複雜度
接口: 與 OrbitEngineAdapter.calculate_state() 完全相同

Academic Standard:
- No computation during training (pure lookup)
- States precomputed using complete physics (ITU-R + 3GPP + SGP4)
- 100% reproducible results
- Transparent to training code (drop-in replacement)

Performance:
- Query time: < 1 ms (vs ~100 ms for real-time calculation)
- Memory efficient: Only loads accessed datasets
- Thread-safe: Can be used in multiprocessing
"""

import h5py
import numpy as np
from datetime import datetime
from typing import Dict, List, Optional
import logging
from bisect import bisect_left

logger = logging.getLogger(__name__)


class OrbitPrecomputeTable:
    """
    Fast query interface for precomputed orbit states.

    提供與 OrbitEngineAdapter.calculate_state() 相同的 API，
    但使用 O(1)/O(log n) 查表代替實時物理計算。

    Example:
        table = OrbitPrecomputeTable("data/orbit_precompute_7days.h5")

        # Same API as OrbitEngineAdapter
        state = table.calculate_state(
            satellite_id="starlink_47925",
            timestamp=datetime(2025, 10, 7, 12, 30, 15)
        )

        # Returns same dict format:
        # {
        #     'rsrp_dbm': -85.5,
        #     'elevation_deg': 45.2,
        #     ... (12 fields)
        # }
    """

    # Field names (same as OrbitPrecomputeGenerator)
    STATE_FIELDS = [
        'rsrp_dbm',
        'rsrq_db',
        'rs_sinr_db',
        'distance_km',
        'elevation_deg',
        'doppler_shift_hz',
        'radial_velocity_ms',
        'atmospheric_loss_db',
        'path_loss_db',
        'propagation_delay_ms',
        'offset_mo_db',
        'cell_offset_db',
    ]

    def __init__(self, hdf5_path: str):
        """
        Load precomputed table.

        Args:
            hdf5_path: Path to HDF5 file generated by OrbitPrecomputeGenerator
        """
        self.hdf5_path = hdf5_path
        self.h5file = None  # Will be opened on demand

        # Load metadata
        # Use optimized HDF5 settings (512 MB cache to prevent I/O bottleneck)
        with h5py.File(hdf5_path, 'r', rdcc_nbytes=512*1024*1024, rdcc_nslots=10007, rdcc_w0=0.75) as f:
            meta = f['metadata']
            self.generation_time = meta.attrs['generation_time']
            self.tle_epoch_start = datetime.fromisoformat(meta.attrs['tle_epoch_start'])
            self.tle_epoch_end = datetime.fromisoformat(meta.attrs['tle_epoch_end'])
            self.time_step_seconds = meta.attrs['time_step_seconds']
            self.num_satellites = meta.attrs['num_satellites']
            self.num_timesteps = meta.attrs['num_timesteps']

            # Load satellite IDs
            self.satellite_ids = [
                sid.decode('utf-8') if isinstance(sid, bytes) else sid
                for sid in meta['satellite_ids'][:]
            ]

            # Load timestamps (Unix timestamps)
            self.unix_timestamps = f['timestamps']['utc_timestamps'][:]

        # Build timestamp index for fast lookup
        self._build_timestamp_index()

        logger.info(f"OrbitPrecomputeTable loaded: {hdf5_path}")
        logger.info(f"  Time range: {self.tle_epoch_start} to {self.tle_epoch_end}")
        logger.info(f"  Satellites: {self.num_satellites}")
        logger.info(f"  Timesteps: {self.num_timesteps:,}")
        logger.info(f"  Time step: {self.time_step_seconds}s")

    def _build_timestamp_index(self):
        """
        Build timestamp index for O(log n) binary search.

        Timestamps are sorted, so we can use bisect for fast lookup.
        """
        # Already sorted in generation, just store
        self.timestamps_sorted = self.unix_timestamps
        self.start_timestamp = self.timestamps_sorted[0]
        self.end_timestamp = self.timestamps_sorted[-1]

        logger.debug(f"Timestamp index built: {len(self.timestamps_sorted)} entries")

    def calculate_state(self,
                       satellite_id: str,
                       timestamp: datetime,
                       tle: Optional[object] = None) -> Dict:
        """
        Query precomputed state (drop-in replacement for OrbitEngineAdapter).

        This method has the same signature as OrbitEngineAdapter.calculate_state()
        so it can be used as a transparent replacement in training code.

        Args:
            satellite_id: Satellite ID (e.g., "starlink_47925")
            timestamp: Query time (UTC)
            tle: Ignored (for API compatibility)

        Returns:
            State dictionary with 12 fields + metadata, same format as
            OrbitEngineAdapter.calculate_state()

        Raises:
            ValueError: If satellite_id not found or timestamp out of range
        """
        # Validate satellite ID
        if satellite_id not in self.satellite_ids:
            raise ValueError(
                f"Satellite {satellite_id} not found in precomputed table. "
                f"Available: {len(self.satellite_ids)} satellites"
            )

        # Find closest timestamp index
        timestamp_index = self._find_timestamp_index(timestamp)

        if timestamp_index is None:
            raise ValueError(
                f"Timestamp {timestamp} out of range. "
                f"Table range: {self.tle_epoch_start} to {self.tle_epoch_end}"
            )

        # Query state from HDF5
        state = self._query_state_by_index(satellite_id, timestamp_index)

        # Add metadata (for compatibility with OrbitEngineAdapter API)
        state['timestamp'] = timestamp.isoformat()
        state['satellite_id'] = satellite_id
        state['tle_epoch'] = self.tle_epoch_start.isoformat()
        state['is_connectable'] = (
            not np.isnan(state['elevation_deg']) and
            state['elevation_deg'] >= 10.0  # Assuming 10° min elevation
        )

        return state

    def _find_timestamp_index(self, timestamp: datetime) -> Optional[int]:
        """
        Find closest timestamp index using binary search.

        Args:
            timestamp: Query timestamp

        Returns:
            Index in timestamps array, or None if out of range

        Method:
            1. Convert timestamp to Unix timestamp
            2. Use bisect_left for O(log n) search
            3. Return closest index
        """
        query_unix = timestamp.timestamp()

        # Check range
        if query_unix < self.start_timestamp or query_unix > self.end_timestamp:
            logger.warning(
                f"Timestamp {timestamp} out of range "
                f"({datetime.fromtimestamp(self.start_timestamp)} to "
                f"{datetime.fromtimestamp(self.end_timestamp)})"
            )
            return None

        # Binary search for closest timestamp
        idx = bisect_left(self.timestamps_sorted, query_unix)

        # Handle edge cases
        if idx == 0:
            return 0
        elif idx == len(self.timestamps_sorted):
            return len(self.timestamps_sorted) - 1
        else:
            # Choose closest: idx-1 or idx
            before = self.timestamps_sorted[idx - 1]
            after = self.timestamps_sorted[idx]

            if abs(query_unix - before) < abs(query_unix - after):
                return idx - 1
            else:
                return idx

    def _query_state_by_index(self, satellite_id: str, timestamp_index: int) -> Dict:
        """
        Query state for a specific (satellite, timestamp_index).

        Args:
            satellite_id: Satellite ID
            timestamp_index: Index in timestamps array

        Returns:
            State dictionary with 12 fields
        """
        # Open HDF5 file on demand (lazy loading)
        if self.h5file is None:
            # Optimize HDF5 read performance with larger chunk cache
            # rdcc_nbytes: 512 MB cache (default: 1 MB) - prevents disk I/O bottleneck
            # rdcc_nslots: 10007 slots (prime number for hash table)
            # rdcc_w0: 0.75 preemption policy (balance between speed and memory)
            self.h5file = h5py.File(
                self.hdf5_path,
                'r',
                rdcc_nbytes=512*1024*1024,  # 512 MB chunk cache
                rdcc_nslots=10007,           # Hash table slots
                rdcc_w0=0.75                 # Preemption policy
            )

        states_group = self.h5file['states']
        sat_group = states_group[satellite_id]

        # Read all 12 fields for this timestep
        state = {}
        for field in self.STATE_FIELDS:
            state[field] = float(sat_group[field][timestamp_index])

        return state

    def query_state(self, satellite_id: str, timestamp: datetime) -> Dict:
        """
        Alias for calculate_state (for clarity).

        This method name makes it clear this is a table lookup.
        """
        return self.calculate_state(satellite_id, timestamp)

    def get_available_satellites(self) -> List[str]:
        """Get list of available satellite IDs."""
        return self.satellite_ids.copy()

    def get_time_range(self) -> tuple:
        """Get (start_time, end_time) of table."""
        return (self.tle_epoch_start, self.tle_epoch_end)

    def get_metadata(self) -> Dict:
        """Get table metadata."""
        return {
            'hdf5_path': self.hdf5_path,
            'generation_time': self.generation_time,
            'tle_epoch_start': self.tle_epoch_start.isoformat(),
            'tle_epoch_end': self.tle_epoch_end.isoformat(),
            'time_step_seconds': self.time_step_seconds,
            'num_satellites': self.num_satellites,
            'num_timesteps': self.num_timesteps,
        }

    def close(self):
        """Close HDF5 file (call when done)."""
        if self.h5file is not None:
            self.h5file.close()
            self.h5file = None

    def __enter__(self):
        """Context manager support."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager cleanup."""
        self.close()

    def __del__(self):
        """Cleanup on deletion."""
        self.close()


if __name__ == '__main__':
    # Example usage
    import sys

    if len(sys.argv) < 2:
        print("Usage: python orbit_precompute_table.py <hdf5_file>")
        print("Example: python orbit_precompute_table.py data/orbit_precompute_7days.h5")
        sys.exit(1)

    # Test query
    table = OrbitPrecomputeTable(sys.argv[1])

    print("\n=== Table Metadata ===")
    metadata = table.get_metadata()
    for key, value in metadata.items():
        print(f"  {key}: {value}")

    print(f"\n=== Available Satellites ({len(table.satellite_ids)}) ===")
    print(f"  First 5: {table.satellite_ids[:5]}")

    if len(table.satellite_ids) > 0:
        # Test query
        sat_id = table.satellite_ids[0]
        test_time = table.tle_epoch_start + timedelta(hours=1)

        print(f"\n=== Test Query ===")
        print(f"  Satellite: {sat_id}")
        print(f"  Timestamp: {test_time}")

        state = table.query_state(sat_id, test_time)
        print(f"\n  State (12 dimensions):")
        for field in OrbitPrecomputeTable.STATE_FIELDS:
            print(f"    {field:25s}: {state[field]:10.3f}")

    table.close()
